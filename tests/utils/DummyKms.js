const async = require('async');
const crypto = require('crypto');

const errors = require('../../lib/errors').default;
const kms = [];
let count = 1;

/** Class exposing common createDataKey,
createDecipher and createCipher functions. */
class Common {
    static _algorithm() {
        return 'aes-256-ctr';
    }

    /* AES-256 Key */
    static _keySize() {
        return 32;
    }

    /* IV is 128bit for AES-256-CTR */
    static _IVSize() {
        return 16;
    }

    /* block size is 128bit for AES-256-CTR */
    static _aesBlockSize() {
        return 16;
    }

    /**
    Creates data key to encrypt and decrypt the actual data (which data
    key is ciphered and deciphered by the appliance). The encrypted data key
    is stored in the object's metadata. We also use this function to create
    the bucket key for the file and in memory implementations.
    @return {buffer} - random key
    */
    static createDataKey() {
        return Buffer.from(crypto.randomBytes(this._keySize()));
    }

    /**
     *
     * @param {buffer} derivedIV - the stringified bucket
     * @param {number} counter - quotient of the offset and blocksize
     * @return {buffer} - the incremented IV
     */
    static _incrementIV(derivedIV, counter) {
        const newIV = derivedIV;
        const len = derivedIV.length;
        let i = len - 1;
        let ctr = counter;
        while (ctr !== 0) {
            const mod = (ctr + newIV[i]) % 256;
            ctr = Math.floor((ctr + newIV[i]) / 256);
            newIV[i] = mod;
            i -= 1;
            if (i < 0) {
                i = len - 1;
            }
        }
        return newIV;
    }

    /**
      * Derive key to use in cipher
      * @param {number} cryptoScheme - cryptoScheme being used
      * @param {buffer} dataKey - the unencrypted key (either from the
      * appliance on a get or originally generated by kms in the case of a put)
      * @param {object} log - logger object
      * @param {function} cb - cb from createDecipher
      * @returns {undefined}
      * @callback called with (err, derivedKey, derivedIV)
      */
    static _deriveKey(cryptoScheme, dataKey, log, cb) {
        if (cryptoScheme <= 1) {
            /* we are not storing hashed human password.
             * It's a random key, so 1 iteration and
             * a fixed salt is enough for our usecase.
             * don't change the salt, the iteration number
             * or the digest algorithm (sha1 here) without
             * bumping the cryptoScheme number saved in the object
             * metadata along with the dataKey.
             */
            const salt = Buffer.from('ItsTasty', 'utf8');
            const iterations = 1;
            return crypto.pbkdf2(
                dataKey, salt, iterations,
                this._keySize(), 'sha1', (err, derivedKey) => {
                    if (err) {
                        log.error('pbkdf2 function failed on key derivation',
                            { error: err });
                        cb(errors.InternalError);
                        return;
                    }
                    crypto.pbkdf2(
                        derivedKey, salt, iterations,
                        this._IVSize(), 'sha1', (err, derivedIV) => {
                            if (err) {
                                log.error(
                                    'pbkdf2 function failed on IV derivation',
                                    { error: err });
                                return cb(errors.InternalError);
                            }
                            // derivedKey is the actual data encryption or
                            // decryption key used in the AES ctr cipher
                            return cb(null, derivedKey, derivedIV);
                        });
                });
        }
        log.error('Unknown cryptographic scheme', { cryptoScheme });
        return cb(errors.InternalError);
    }

    /**
      * createDecipher
      * @param {number} cryptoScheme - cryptoScheme being used
      * @param {buffer} dataKey - the unencrypted key (either from the
      * appliance on a get or originally generated by kms in the case of a put)
      * @param {number} offset - offset
      * @param {object} log - logger object
      * @param {function} cb - cb from external call
      * @returns {undefined}
      * @callback called with (err, decipher: ReadWritable.stream)
      */
    static createDecipher(cryptoScheme, dataKey, offset, log, cb) {
        this._deriveKey(
            cryptoScheme, dataKey, log,
            (err, derivedKey, derivedIV) => {
                if (err) {
                    log.debug('key derivation failed', { error: err });
                    return cb(err);
                }
                const aesBlockSize = this._aesBlockSize();
                const blocks = Math.floor(offset / aesBlockSize);
                const toSkip = offset % aesBlockSize;
                const iv = this._incrementIV(derivedIV, blocks);
                const cipher = crypto.createDecipheriv(this._algorithm(),
                    derivedKey, iv);
                if (toSkip) {
                    /* Above, we advanced to the latest boundary not
                    greater than the offset amount. Here we advance by
                    the toSkip amount if necessary. */
                    const dummyBuffer = Buffer.alloc(toSkip);
                    cipher.write(dummyBuffer);
                    cipher.read();
                }
                return cb(null, cipher);
            });
    }

    /**
     * createCipher (currently same as createDecipher function above.  this
     * wrapper is included to preserve flexibility)
     * @param {number} cryptoScheme - cryptoScheme being used
     * @param {buffer} dataKey - the unencrypted key (either from the
     * appliance on a get or originally generated by kms in the case of a put)
     * @param {number} offset - offset
     * @param {object} log - logger object
     * @param {function} cb - cb from external call
     * @returns {undefined}
     * @callback called with (err, cipher: ReadWritable.stream)
     */
    static createCipher(cryptoScheme, dataKey, offset, log, cb) {
        /* aes-256-ctr decipher is both ways */
        this.createDecipher(cryptoScheme, dataKey, offset, log, cb);
    }
}

const backend = {
    /*
     * Target implementation will be async. let's mimic it
     */

    /**
      *
      * @param {string} bucketName - bucket name
      * @param {object} log - logger object
      * @param {function} cb - callback
      * @returns {undefined}
      * @callback called with (err, masterKeyId: string)
      */
    createBucketKey: function createBucketKeyMem(bucketName, log, cb) {
        process.nextTick(() => {
            // Using createDataKey here for purposes of createBucketKeyMem
            // so that we do not need a separate function.
            kms[count] = Common.createDataKey();
            cb(null, (count++).toString());
        });
    },

    /**
     *
     * @param {string} bucketKeyId - the Id of the bucket key
     * @param {object} log - logger object
     * @param {function} cb - callback
     * @returns {undefined}
     * @callback called with (err)
     */
    destroyBucketKey: function destroyBucketKeyMem(bucketKeyId, log, cb) {
        process.nextTick(() => {
            kms[bucketKeyId] = undefined;
            cb(null);
        });
    },

    /**
      *
      * @param {number} cryptoScheme - crypto scheme version number
      * @param {string} masterKeyId - key to retrieve master key
      * @param {buffer} plainTextDataKey - data key
      * @param {object} log - logger object
      * @param {function} cb - callback
      * @returns {undefined}
      * @callback called with (err, cipheredDataKey: Buffer)
      */
    cipherDataKey: function cipherDataKeyMem(cryptoScheme,
        masterKeyId,
        plainTextDataKey,
        log,
        cb) {
        process.nextTick(() => {
            Common.createCipher(
                cryptoScheme, kms[masterKeyId], 0, log,
                (err, cipher) => {
                    if (err) {
                        cb(err);
                        return;
                    }
                    let cipheredDataKey =
                            cipher.update(plainTextDataKey);
                    // call final() to ensure that any bytes remaining in
                    // the output of the stream are captured
                    const final = cipher.final();
                    if (final.length !== 0) {
                        cipheredDataKey =
                            Buffer.concat([cipheredDataKey,
                                final]);
                    }
                    cb(null, cipheredDataKey);
                });
        });
    },

    /**
      *
      * @param {number} cryptoScheme - crypto scheme version number
      * @param {string} masterKeyId - key to retrieve master key
      * @param {buffer} cipheredDataKey - data key
      * @param {object} log - logger object
      * @param {function} cb - callback
      * @returns {undefined}
      * @callback called with (err, plainTextDataKey: Buffer)
      */
    decipherDataKey: function decipherDataKeyMem(cryptoScheme,
        masterKeyId,
        cipheredDataKey,
        log,
        cb) {
        process.nextTick(() => {
            Common.createDecipher(
                cryptoScheme, kms[masterKeyId], 0, log,
                (err, decipher) => {
                    if (err) {
                        cb(err);
                        return;
                    }
                    let plainTextDataKey =
                            decipher.update(cipheredDataKey);
                    const final = decipher.final();
                    if (final.length !== 0) {
                        plainTextDataKey =
                            Buffer.concat([plainTextDataKey,
                                final]);
                    }
                    cb(null, plainTextDataKey);
                });
        });
    },

};

const client = backend;
const implName = 'mem';

class KMS {
    /**
     *
     * @param {string} bucketName - bucket name
     * @param {object} log - logger object
     * @param {function} cb - callback
     * @returns {undefined}
     * @callback called with (err, masterKeyId: string)
     */
    static createBucketKey(bucketName, log, cb) {
        log.debug('creating a new bucket key');
        client.createBucketKey(bucketName, log, (err, masterKeyId) => {
            if (err) {
                log.debug('error from kms', { implName, error: err });
                return cb(err);
            }
            log.trace('bucket key created in kms');
            return cb(null, masterKeyId);
        });
    }

    /**
         *
         * @param {string} bucketName - bucket name
         * @param {object} headers - request headers
         * @param {object} log - logger object
         * @param {function} cb - callback
         * @returns {undefined}
         * @callback called with (err, serverSideEncryptionInfo: object)
         */
    static bucketLevelEncryption(bucketName, headers, log, cb) {
        const sseAlgorithm = headers['x-amz-scal-server-side-encryption'];
        const sseMasterKeyId =
                    headers['x-amz-scal-server-side-encryption-aws-kms-key-id'];
        /*
        The purpose of bucket level encryption is so that the client does not
        have to send appropriate headers to trigger encryption on each object
        put in an "encrypted bucket". Customer provided keys are not
        feasible in this system because we do not want to store this key
        in the bucket metadata.
            */
        if (sseAlgorithm === 'AES256' ||
            (sseAlgorithm === 'aws:kms' && sseMasterKeyId === undefined)) {
            this.createBucketKey(bucketName, log, (err, masterKeyId) => {
                if (err) {
                    cb(err);
                    return;
                }
                const serverSideEncryptionInfo = {
                    cryptoScheme: 1,
                    algorithm: sseAlgorithm,
                    masterKeyId,
                    mandatory: true,
                };
                cb(null, serverSideEncryptionInfo);
            });
        } else if (sseAlgorithm === 'aws:kms') {
            const serverSideEncryptionInfo = {
                cryptoScheme: 1,
                algorithm: sseAlgorithm,
                masterKeyId: sseMasterKeyId,
                mandatory: true,
            };
            cb(null, serverSideEncryptionInfo);
        } else {
            /*
                * no encryption
                */
            cb(null, null);
        }
    }

    /**
        *
        * @param {string} bucketKeyId - the Id of the bucket key
        * @param {object} log - logger object
        * @param {function} cb - callback
        * @returns {undefined}
        * @callback called with (err)
        */
    static destroyBucketKey(bucketKeyId, log, cb) {
        log.debug('deleting bucket key', { bucketKeyId });
        client.destroyBucketKey(bucketKeyId, log, err => {
            if (err) {
                log.debug('error from kms', { implName, error: err });
                return cb(err);
            }
            log.trace('bucket key destroyed in kms');
            return cb(null);
        });
    }

    /**
        *
        * @param {object} log - logger object
        * @returns {buffer} newKey - a data key
        */
    static createDataKey(log) {
        log.debug('creating a new data key');
        const newKey = Common.createDataKey();
        log.trace('data key created by the kms');
        return newKey;
    }


    /**
         * createCipherBundle
         * @param {object} serverSideEncryptionInfo - info for encryption
         * @param {number} serverSideEncryptionInfo.cryptoScheme -
         * cryptoScheme used
         * @param {string} serverSideEncryptionInfo.algorithm -
         * algorithm to use
         * @param {string} serverSideEncryptionInfo.masterKeyId -
         * key to get master key
         * @param {boolean} serverSideEncryptionInfo.mandatory -
         * true for mandatory encryption
         * @param {object} log - logger object
         * @param {function} cb - cb from external call
         * @returns {undefined}
         * @callback called with (err, cipherBundle)
         */
    static createCipherBundle(serverSideEncryptionInfo,
        log, cb) {
        const dataKey = this.createDataKey(log);
        const cipherBundle = {
            algorithm: serverSideEncryptionInfo.algorithm,
            masterKeyId: serverSideEncryptionInfo.masterKeyId,
            cryptoScheme: 1,
            cipheredDataKey: null,
            cipher: null,
        };

        async.waterfall([
            function cipherDataKey(next) {
                log.debug('ciphering a data key');
                return client.cipherDataKey(cipherBundle.cryptoScheme,
                    serverSideEncryptionInfo.masterKeyId,
                    dataKey, log, (err, cipheredDataKey) => {
                        if (err) {
                            log.debug('error from kms',
                                { implName, error: err });
                            return next(err);
                        }
                        log.trace('data key ciphered by the kms');
                        return next(null, cipheredDataKey);
                    });
            },
            function createCipher(cipheredDataKey, next) {
                log.debug('creating a cipher');
                cipherBundle.cipheredDataKey =
                    cipheredDataKey.toString('base64');
                return Common.createCipher(cipherBundle.cryptoScheme,
                    dataKey, 0, log, (err, cipher) => {
                        dataKey.fill(0);
                        if (err) {
                            log.debug('error from kms',
                                { implName, error: err });
                            return next(err);
                        }
                        log.trace('cipher created by the kms');
                        return next(null, cipher);
                    });
            },
            function finishCipherBundle(cipher, next) {
                cipherBundle.cipher = cipher;
                return next(null, cipherBundle);
            },
        ], (err, cipherBundle) => {
            if (err) {
                log.error('error processing cipher bundle',
                    { implName, error: err });
            }
            return cb(err, cipherBundle);
        });
    }

    /**
         * createDecipherBundle
         * @param {object} serverSideEncryptionInfo - info for decryption
         * @param {number} serverSideEncryptionInfo.cryptoScheme -
         * cryptoScheme used
         * @param {string} serverSideEncryptionInfo.algorithm -
         * algorithm to use
         * @param {string} serverSideEncryptionInfo.masterKeyId -
         * key to get master key
         * @param {boolean} serverSideEncryptionInfo.mandatory -
         * true for mandatory encryption
         * @param {buffer} serverSideEncryptionInfo.cipheredDataKey -
         * ciphered data key
         * @param {number} offset - offset for decryption
         * @param {object} log - logger object
         * @param {function} cb - cb from external call
         * @returns {undefined}
         * @callback called with (err, decipherBundle)
         */
    static createDecipherBundle(serverSideEncryptionInfo, offset,
        log, cb) {
        if (!serverSideEncryptionInfo.masterKeyId ||
            !serverSideEncryptionInfo.cipheredDataKey ||
            !serverSideEncryptionInfo.cryptoScheme) {
            log.error('Invalid cryptographic information', { implName });
            return cb(errors.InternalError);
        }
        const decipherBundle = {
            cryptoScheme: serverSideEncryptionInfo.cryptoScheme,
            decipher: null,
        };
        return async.waterfall([
            function decipherDataKey(next) {
                return client.decipherDataKey(
                    decipherBundle.cryptoScheme,
                    serverSideEncryptionInfo.masterKeyId,
                    serverSideEncryptionInfo.cipheredDataKey,
                    log, (err, plainTextDataKey) => {
                        log.debug('deciphering a data key');
                        if (err) {
                            log.debug('error from kms',
                                { implName, error: err });
                            return next(err);
                        }
                        log.trace('data key deciphered by the kms');
                        return next(null, plainTextDataKey);
                    });
            },
            function createDecipher(plainTextDataKey, next) {
                log.debug('creating a decipher');
                return Common.createDecipher(decipherBundle.cryptoScheme,
                    plainTextDataKey, offset, log, (err, decipher) => {
                        plainTextDataKey.fill(0);
                        if (err) {
                            log.debug('error from kms',
                                { implName, error: err });
                            return next(err);
                        }
                        log.trace('decipher created by the kms');
                        return next(null, decipher);
                    });
            },
            function finishDecipherBundle(decipher, next) {
                decipherBundle.decipher = decipher;
                return next(null, decipherBundle);
            },
        ], (err, decipherBundle) => {
            if (err) {
                log.error('error processing decipher bundle',
                    { implName, error: err });
                return cb(err);
            }
            return cb(err, decipherBundle);
        });
    }
}

module.exports = KMS;
